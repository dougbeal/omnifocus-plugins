/*{
	"type": "action",
	"targets": ["omnifocus"],
	"author": "Kaitlin Salzke",
	"identifier": "com.KaitlinSalzke.sortByImportance",
	"version": "1.0",
	"description": "",
	"label": "Sort By Importance",
	"shortLabel": "Sort By Importance"
}*/

var later;

var _ = (function() {
  var action = new PlugIn.Action(function(selection, sender) {
    if (typeof setImmediate === "undefined") {
      later = function(fn) {
        return Timer.once(0, fn);
      };
    } else {
      later = setImmediate;
    }

    unsortedArray = [3, 1, 5];

    /* unsortedArray = [
      332,
      372,
      291,
      244,
      196,
      396,
      386,
      48,
      234,
      405,
      195,
      240,
      265,
      493,
      461,
      15,
      55,
      383,
      476,
      45,
      66,
      434,
      237,
      142,
      119,
      408,
      63,
      439,
      54,
      355
    ]; */

    result = asyncMergeSort(
      unsortedArray,
      function(a, b, callback) {
        new Alert("More important?", "I am a message in the alert.").show(
          function(result) {
            if (a < b) {
              return callback(null, -1);
            } else {
              return callback(null, 1);
            }
          }
        );
      },
      function(err, sorted) {
        if (err) {
          alert("Oh dear, an error occurred.");
        }
        console.log(sorted);
      }
    );

    // console.log(result);
  });

  action.validate = function(selection, sender) {
    // validation code
    // selection options: tasks, projects, folders, tags
    return true;
  };

  return action;
})();
_;

function asyncMergeSort(items, comparator, callback) {
  // dice into lists of length 1, which are considered to be
  // internally sorted
  var lists = [];
  for (var i = 0; i < items.length; i++) {
    lists.push([items[i]]);
  }

  // if there are no items, we're done
  if (!lists.length) {
    return callback(null, []);
  }

  // Make the first merging pass
  return pass();

  function pass() {
    var x = 0;
    var newLists = [];
    if (lists.length === 1) {
      // one list left, we're done
      return callback(null, lists[0]);
    }
    return merge(x, x + 1);

    function merge() {
      if (x + 1 >= lists.length) {
        if (x + 1 == lists.length) {
          newLists.push(lists[x]);
        }
        lists = newLists;
        return later(pass);
      }

      var listOne = lists[x];
      var listTwo = lists[x + 1];
      var indexOne = 0;
      var indexTwo = 0;
      var newList = [];
      // compare the first pair
      consider();

      function consider() {
        if (indexOne === listOne.length) {
          if (indexTwo === listTwo.length) {
            newLists.push(newList);
            x += 2;
            return merge();
          }
          newList.push(listTwo[indexTwo++]);
          // make async to avoid stack crashes
          return later(consider);
        } else if (indexTwo === listTwo.length) {
          newList.push(listOne[indexOne++]);
          // make async to avoid stack crashes
          return later(consider);
        }
        return comparator(listOne[indexOne], listTwo[indexTwo], function(
          err,
          value
        ) {
          if (err) {
            return callback(err);
          }
          if (value === -1) {
            newList.push(listOne[indexOne++]);
          } else if (value === 1) {
            newList.push(listTwo[indexTwo++]);
          } else {
            newList.push(listOne[indexOne++]);
            newList.push(listTwo[indexTwo++]);
          }
          return consider();
        });
      }
    }
  }
}
